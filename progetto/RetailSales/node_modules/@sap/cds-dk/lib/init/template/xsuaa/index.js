const { join } = require('path')
const cds = require('../../../cds')
const { read } = cds.utils
const { readProject } = require('../../util/projectReader')
const { mergeJSON, mergeYAML } = require('../../util/merge')
const { parseMd5File, writeMd5File } = require('../../util/md5')
const { srvNode4, srvJava4, xsuaa, mtxSidecar4 } = require('../_merging/registry-mta')

module.exports = class XsuaaTemplate extends require('../templateBase') {

    static hasFacet(env) {
        return env.requires?.auth?.kind === 'xsuaa'
    }

    async run() {
        const projectDescriptor = await readProject(this.options)
        const { configFile } = projectDescriptor.cap
        projectDescriptor.cap.shortcut = !(await read(configFile)).cds?.requires?.auth?.kind
        await mergeJSON(configFile, join(__dirname, 'files', 'package.json.hbs'), projectDescriptor, { forceOverwrite: true })
        await this.runDependentMerging()
    }

    async runDependentMerging( context = {}) {
        const projectDescriptor = await readProject(this.options)
        const { isMultitenant, isExtensible, hasMta, hasHelm, isJava, srvPath } = projectDescriptor.cap

        const cds = require('../../../../lib/compile')
        const xsSecurity = await (async () => { try {
            const models = await cds.load(cds.env.folders.srv)
            return cds.compile.to.xsuaa(models)
        } catch (error) { /* ignore */ }
        })() || { scopes: [], attributes: [], 'role-templates': [], 'authorities-inheritance': false }
        const mergingSemantics = { additions: xsSecurity.scopes.map(scope => ({
            in: 'scopes',
            where: [{
                property: 'name',
                isEqualTo: scope.name
            }],
        }))}
        await mergeJSON('xs-security.json', xsSecurity, projectDescriptor, mergingSemantics)

        if (hasMta) {
            const srv = (isJava ? srvJava4 : srvNode4)(srvPath)
            const additions = [srv, xsuaa]
            const mtxSidecar = mtxSidecar4(isJava ? 'mtx/sidecar' : 'gen/mtx/sidecar')
            if (isMultitenant && isJava) additions.push(mtxSidecar)

            const relationships = [{
                insert: [xsuaa, 'name'],
                into: [srv, 'requires', 'name']
            }]
            if (isMultitenant) relationships.push({
                insert: [xsuaa, 'name'],
                into: [mtxSidecar, 'requires', 'name']
            })

            await mergeYAML('mta.yaml', join(__dirname, 'files', 'mta.yaml.hbs'), projectDescriptor, { additions, relationships })
        }

        if (hasHelm) {
            //in case facet is being added to the already exisiting charts folder
            let isIndependentCommand = false;
            if(Object.keys(context).length == 0){
                isIndependentCommand = true;
                context.oldTrackingData = context.newTrackingData = await parseMd5File(join('chart', '.cds-add-helm-files.md5'));
            }

            // copy service-instance chart
            const HelmTemplate = require(`../helm`);
            const helmTemplate = new HelmTemplate(this.generator, context.oldTrackingData, context.newTrackingData);
            isIndependentCommand = isIndependentCommand | await helmTemplate.addSubChart('service-instance');

            // add dependency entry in chart.yaml
            await helmTemplate.addDependency('service-instance', 'xsuaa');

            await mergeYAML(
                join('chart', 'values.yaml'),
                join(__dirname, 'files', 'values.yaml.hbs'),
                projectDescriptor
            )
            if(isIndependentCommand) await writeMd5File(join('chart', '.cds-add-helm-files.md5'), context.newTrackingData);
        }

        // Re-applying the merging part of `cds add mtx` because cds.compile.to.xsuaa
        // has overwritten the existing `xs-security.json`.
        // TODO: Find a generic solution for situation like these.
        if (isMultitenant) {
            const MultitenancyTemplate = require(`../multitenancy`)
            const multitenancyTemplate = new MultitenancyTemplate(this.generator)
            await multitenancyTemplate.runDependentMerging(context)
        }

        if (isExtensible) {
            const ExtensibilityTemplate = require(`../extensibility`)
            const extensibilityTemplate = new ExtensibilityTemplate(this.generator)
            await extensibilityTemplate.runDependentMerging(context)
        }
    }
}
