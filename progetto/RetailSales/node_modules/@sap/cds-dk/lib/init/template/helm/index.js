const { join } = require('path');
const { exists, rimraf } = require('../../../cds').utils;
const { readProject } = require('../../util/projectReader');
const { mergeYAML } = require('../../util/merge')
const { parseMd5File, writeMd5File, copyAndTrack } = require('../../util/md5')

module.exports = class HelmTemplate extends require('../templateBase') {
    constructor(generator, oldTrackingData = undefined, newTrackingData = {}) {
        super(generator)
        this.oldTrackingData = oldTrackingData;
        this.newTrackingData = newTrackingData;
    }

    static hasFacet(_, options) {
        // REVISIT: this works, but could be semantically nicer with a 'shouldRunDependentMerging' or the like
        if (options?.add.has('mta') && !options?.add.has('helm')) return false
        return exists(join('chart', 'values.yaml'))
    }

    async canRun() {
        if (this.options.force) {
            await rimraf(join('chart'))
            return true;
        }
        return true;
    }

    async addSubChart(subchart, force = false) {
        const subchartPath = join('chart', 'charts', subchart);
        const isInternal = !force && await this.isInternal();
        if(!exists(subchartPath) && !isInternal) {
            await copyAndTrack(
                join(__dirname, 'subcharts', subchart),
                subchartPath,
                this
            )

            return true;
        }

        return false;
    }

    async isInternal() {
        return !exists(join('chart', 'charts', 'web-application')) || this.options['internal-unified-runtime-charts'];
    }

    async addDependency(name, alias){
        const projectDescriptor = await readProject(this.options);
        const isInternal = await this.isInternal();
        await mergeYAML(
            join('chart', 'Chart.yaml'),
            {
                dependencies: [
                    {
                        name,
                        alias,
                        version: '>0.0.0',
                        ...(isInternal) && { repository: 'https://int.repositories.cloud.sap/artifactory/virtual-unified-runtime-helm-dmz' }
                    }
                ]
            },
            projectDescriptor,
            { additions: [{
                in: `dependencies`,
                where: [{
                    property: 'alias',
                    isEqualTo: alias
                }]
            }]}
        )
    }

    async run() {
        const projectDescriptor = await readProject(this.options)
        const isInternal = this.options['internal-unified-runtime-charts'] !== undefined && this.options['internal-unified-runtime-charts'];
        this.oldTrackingData = await parseMd5File(join('chart', '.cds-add-helm-files.md5'));
        await this.addSubChart('web-application', !isInternal);
        await copyAndTrack(
            join(__dirname, 'chart'),
            join('chart'),
            this
        )

        await mergeYAML(
            join('chart', 'Chart.yaml'),
            join(__dirname, 'files', 'Chart.yaml.hbs'),
            projectDescriptor
        )

        await this.addDependency('web-application', 'srv');

        await mergeYAML(
            join('chart', 'values.yaml'),
            join(__dirname, 'files', 'values.yaml.hbs'),
            projectDescriptor
        )
        await this.runDependentMerging();
        await writeMd5File(join('chart', '.cds-add-helm-files.md5'), this.newTrackingData);
    }

    async runDependentMerging() {
        // Re-applying the dependent merging part of other facets if necessary.
        const dependentFacets = ['hana', 'xsuaa', 'auditlog', 'enterprise-messaging', 'destinations' , 'multitenancy', 'extensibility', 'approuter']
        for (const facet of dependentFacets) {
            const Template = require('../'+facet)
            const template = new Template(this.generator)
            if (Template.hasFacet(await this.getEnv(), this.options)) await template.runDependentMerging(this)
        }
    }
};
