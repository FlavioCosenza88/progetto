const { join } = require('path')
const cds = require('../../../cds')
const { exists } = cds.utils
const { readProject } = require('../../util/projectReader')
const { mergeJSON, mergeYAML, sortDependencies } = require('../../util/merge')
const { copyAndTrack, parseMd5File, writeMd5File } = require('../../util/md5')
const { copyRenderedJSON } = require('../../../util/fs')
const {
  srvNode4, srvJava4, // Server
  mtxSidecar4, // Additional Modules
  saasRegistry, serviceManager, xsuaa, // BTP Services
  srvApi4, providedMtxApiSidecar4, requiredMtxSidecarApi4 // APIs
} = require('../_merging/registry-mta')

module.exports = class MultitenancyTemplate extends require('../templateBase') {

  static hasFacet(env, options) {
    // REVISIT: Check if this can be simplified
    return options?.add?.has('mtx') || options?.add?.has('multitenancy') ||
           !!env.requires?.multitenancy || !!env.requires?.db?.multiTenant ||
           exists(join('mtx', 'sidecar')) || false
  }

  async run() {
    const projectDescriptor = await readProject(this.options)
    const { isNodejs, configFile } = projectDescriptor.cap
    await mergeJSON(configFile, join(__dirname, 'files', `package.json.hbs`), projectDescriptor)
    if (isNodejs) await sortDependencies('package.json')
    await copyRenderedJSON(join(__dirname, 'files', 'package.sidecar.json.hbs'), join('mtx', 'sidecar', 'package.json'), projectDescriptor)
    await this.runDependentMerging()
  }

  async runDependentMerging(context = {}) {
    const projectDescriptor = await readProject(this.options)
    const { isNodejs, isJava, hasMta, hasHelm, hasApprouter, hasXsuaa, hasHana, srvPath } = projectDescriptor.cap

    if (hasMta) {
      const srv = (isNodejs ? srvNode4 : srvJava4)(srvPath)
      const mtxSidecar = mtxSidecar4(isJava ? 'mtx/sidecar' : 'gen/mtx/sidecar')
      const modules = [srv, mtxSidecar]
      const services = [saasRegistry]
      if (hasXsuaa) services.push(xsuaa)
      const apis = [srvApi4(srv), providedMtxApiSidecar4(mtxSidecar)]
      if (isJava) apis.push(requiredMtxSidecarApi4(srv))
      const additions = [...modules, ...services, ...apis]

      const overwrites = hasXsuaa ? [{ item: [xsuaa, 'parameters.config.tenant-mode'], withValue: 'shared' }] : []

      const relationships =  [{
        insert: [saasRegistry, 'name'],
        into: [isJava ? srv : mtxSidecar, 'requires', 'name']
      }]
      if (hasXsuaa) {
        relationships.push({
          insert: [xsuaa, 'name'],
          into: [mtxSidecar, 'requires', 'name']
        })
      }
      if (hasHana) {
        relationships.push({
          insert: [serviceManager, 'name'],
          into: [mtxSidecar, 'requires', 'name'],
        })
      }

      const templateMtaPath = join(__dirname, 'files', 'mta.yaml.hbs')
      const mergingRules = { additions, overwrites, relationships }
      await mergeYAML('mta.yaml', templateMtaPath, projectDescriptor, mergingRules)
    }

    // REVISIT: Why not just pass a Boolean from run() to indicate the merging isn't run transitively?
    let isIndependentCommand = false
    if (hasHelm) {
      // in case facet is being added to the already existing charts folder
      if (Object.keys(context).length == 0) {
        isIndependentCommand = true
        context.oldTrackingData = context.newTrackingData = await parseMd5File(join('chart', '.cds-add-helm-files.md5'))
      }

      await mergeYAML(
        join('chart', 'values.yaml'),
        join(__dirname, 'files', 'values.yaml.hbs'),
        projectDescriptor
      )

      const envFromObject = {
        envFrom: [
          {
            configMapRef: {
              name: "{{ .Release.Name }}-mtxs-configmap"
            }
          }
        ]
      }

      await mergeYAML(
        join('chart', 'values.yaml'),
        {
          ...(isNodejs) && { sidecar: envFromObject },
          ...(isJava) && { srv: envFromObject },
          "saas-registry": {
            parametersFrom: [
              {
                secretKeyRef: {
                  name: "{{ .Release.Name }}-saas-registry-secret",
                  key: "parameters"
                }
              }
            ]
          }
        },
        projectDescriptor
      )

      // REVISIT: Don't reference other templates except for the safe `runDependentMerging` -> low coupling, high cohesion
      const HelmTemplate = require(`../helm`);
      const helmTemplate = new HelmTemplate(this.generator, context.oldTrackingData, context.newTrackingData);

      await helmTemplate.addDependency('web-application', 'sidecar');

      // copy service-instance chart
      isIndependentCommand = isIndependentCommand | await helmTemplate.addSubChart('service-instance');

      // add dependency entry in chart.yaml
      await helmTemplate.addDependency('service-instance', 'saas-registry');
      await helmTemplate.addDependency('service-instance', 'service-manager');

      // add mtxs configmap
      await copyAndTrack(
        join(__dirname, 'files', `mtxs-configmap-${isJava ? 'java' : 'nodejs'}.yaml`),
        join('chart', 'templates', 'mtxs-configmap.yaml'),
        context,
      )

      // add saas registry secret
      await copyAndTrack(
        join(__dirname, 'files', 'saas-registry-secret.yaml'),
        join('chart', 'templates', 'saas-registry-secret.yaml'),
        context
      );

      if (isIndependentCommand) await writeMd5File(join('chart', '.cds-add-helm-files.md5'), context.newTrackingData)
    }

    if (hasApprouter) {
      const ApprouterTemplate = require(`../approuter`)
      const template = new ApprouterTemplate(this.generator)
      await template.runDependentMerging(context)
    }

    if (hasHana) {
      const HanaTemplate = require(`../hana`)
      const template = new HanaTemplate(this.generator)
      await template.runDependentMerging(context)
    }

    if (hasXsuaa) {
      await mergeJSON(
        'xs-security.json',
        join(__dirname, 'files', 'xs-security.json.hbs'),
        projectDescriptor,
        {
          additions: [{
            in: 'scopes',
            where: [{ property: 'name', isEqualTo: '$XSAPPNAME.mtcallback' }],
          }]
        }
      )
    }

    if (hasXsuaa && hasHelm) {
      await mergeYAML(
          join('chart', 'values.yaml'),
          {
              xsuaa: {
                  parameters: {
                      'tenant-mode': 'shared'
                  }
              }
          },
          null,
          { forceOverwrite: true }
      )
      if (isIndependentCommand) await writeMd5File(join('chart', '.cds-add-helm-files.md5'), context.newTrackingData)
    }
  }
}
