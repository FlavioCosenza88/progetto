const cds = require('../../cds')
const { path, read, exists } = cds.utils
const { parseXml } = require('./xml')
const P_LANGUAGE_JAVA = 'java'
const P_LANGUAGE_NODEJS = 'nodejs'
const DEFAULT_P_LANGUAGE = P_LANGUAGE_NODEJS
const DEBUG = /\b(y|all|cli)\b/.test(process.env.DEBUG) && console.debug
const LOG = console

module.exports = new class ProjectReader {

    constructor() {
        this.readProject = this.readProject.bind(this)
    }

    // REVISIT: There should be a better (and parallelizable) API provided by cds.env
    /**
     * Returns cds.env using 'production' profile by default as mta deployment is executed with having production profile set.
     */
    getEnv(profile = 'production') {
        const cdsEnvVar = process.env.CDS_ENV
        process.env.CDS_ENV = profile
        try {
            // REVISIT: this is invoked 5 times for cds add multitenancy
            return cds.env.for('cds')
        } finally {
            cdsEnvVar ? process.env.CDS_ENV = cdsEnvVar : delete process.env.CDS_ENV
        }
    }

    async readProject(options) {
        // if (options?.cwd) cds.root = options.cwd

        const env = this.getEnv()
        DEBUG && DEBUG({ env })

        const cap = await this._getCapDescriptor(env, options)
        const ui = this._getUiDescriptor(env)
        const projectDescriptor = { cap, ui }

        DEBUG && DEBUG({ projectDescriptor })
        return projectDescriptor
    }

    async _getCapDescriptor(env, options) {
        const _hasFacet = template => require(`../template/${template}`).hasFacet(env, options)
        const cap = {
            for: options?.for,
            language: DEFAULT_P_LANGUAGE,
            srv: {},
            db: [],
            requires: [],
            get hasRequires()    { return this.requires.length > 0 },
            get needsSidecar()   { return (options?.add.has('hana') || this.db.length > 0) && (this.isJava || !this.isMultitenant) },
            get configFile()     { return exists('pom.xml') ? '.cdsrc.json' : 'package.json' },
            get isNodejs()       { return this.language === P_LANGUAGE_NODEJS },
            get isJava()         { return this.language === P_LANGUAGE_JAVA },
            get hasSidecar()     { return exists('mtx', 'sidecar') },
            get isMultitenant()  { return _hasFacet('multitenancy') },
            get isExtensible()   { return _hasFacet('extensibility') },
            get hasHana()        { return _hasFacet('hana') },
            get hasXsuaa()       { return _hasFacet('xsuaa') },
            get hasAuditlog()    { return _hasFacet('auditlog') },
            get hasApprouter()   { return _hasFacet('approuter') },
            get hasDestination() { return _hasFacet('destinations') },
            get hasHtml5Repo()   { return _hasFacet('html5-repo') },
            get hasMta()         { return _hasFacet('mta') },
            get hasHelm()        { return _hasFacet('helm') },
        }

        // setting the effective env as it might have changed by already executed 'add' commands, e.g. cds init foo --add hana,mta
        const cds = require('../../cds')
        cds.env // make sure env is initialized, otherwise we cannot set it (exotic case)
        cds.env = env

        // check whether we have a hana service binding defined as a hana build task is returned by default for compatibility reasons if neither hana, nor sqlite has been defined
        if (this._hasHanaServiceBinding(env)) {
            const dbFolder = env.folders.db.replace(/\/$/, '')
            const relDbDestPath = path.join(env.build.target, dbFolder).replace(/\\/g, '/')
            cap.db.push({ path: relDbDestPath, name: dbFolder })
        }

        const srvFolder = env.folders.srv.replace(/\/$/, '')
        const relSrvDestPath = path.join(env.build.target, srvFolder).replace(/\\/g, '/')
        cap.srvPath = relSrvDestPath
        cap.srvName = srvFolder

        if (env['project-nature'] === 'java') {
            cap.language = P_LANGUAGE_JAVA
            cap.srvExt = await this._getJavaExtDescriptor(path.resolve(cds.root, srvFolder))
        }

        // setting app name, app description...
        await this._setAppDetails(cap)

        // setting required resource information
        this._setResourceDependencies(env, cap)

        return cap
    }

    /**
     * Determines java specific properties for the given module source path.
     * @param {object} srcPath
     */
    async _getJavaExtDescriptor(srcPath) {
        // by default spring-boot:repackage is used creating an executable jar archive
        const pomJson = await parseXml(path.join(srcPath, 'pom.xml'))
        if (pomJson) {
            const dependencies = pomJson?.project?.dependencies?.[0]?.dependency
            const isOldJavaRuntime = [...dependencies].some(d => /com\.sap\.cloud\.servicesdk/.test(d?.groupId?.[0]))
            if (isOldJavaRuntime) {
                throw new Error("Projects using the classic CAP Java SDK are not supported")
            }

            const descriptor = { archiveName: path.basename(cds.root) + "-exec.jar" }
            const archiveName = pomJson?.project?.artifactId?.[0]
            const suffix = pomJson?.project?.packaging?.[0]
            if (archiveName) descriptor.archiveName = archiveName + '-exec.' + suffix
            return descriptor
        }
    }

    _getUiDescriptor(env) {
        const absoluteAppPath = path.join(cds.root, env.folders.app)
        return {
            appPath: exists(absoluteAppPath) ? env.folders.app : null
        }
    }

    async _setAppDetails(cap) {
        if (cap.language !== P_LANGUAGE_JAVA && cap.language !== P_LANGUAGE_NODEJS) {
            throw Error(`${cap.language} not supported`)
        }

        // 1.1. java - use parent pom.xml
        if (cap.language === P_LANGUAGE_JAVA) {
            const pomXmlPath = path.join(cds.root, 'pom.xml')
            try {
                if (exists(pomXmlPath)) {
                    const pomJson = await parseXml(pomXmlPath)
                    const [artifactId] = pomJson?.project?.artifactId ?? []
                    const [description] = pomJson?.project?.description ?? []
                    let [version] = pomJson?.project?.version ?? []
                    // might need to resolve <version>${revision}</version> property
                    if (version.match(/\${1}\{{1}([\w-\\.]+)\}{1}/)?.length === 2) {
                        version = pomJson?.project?.properties?.[0].revision[0]
                    }
                    if (version) {
                        // check compliance with mta version format - copied from mbt build error message
                        // if not compliant we use a static default value, see below...
                        if (/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(-(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(\.(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\+[0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*)?$/.test(version)) {
                            cap.appVersion = version
                        }
                    }
                    if (artifactId) {
                        cap.appName = artifactId.split(/-parent/)[0]
                    }
                    if (description) {
                        cap.appDescription = description
                    }
                }
            } catch (e) {
                LOG.error(`Failed to read file ${pomXmlPath} - skip pom.xml data`)
                LOG.error(e)
            }
        }

        // 1.2. use package.json
        if (!cap.appName) {
            const packageJsonPath = path.join(cds.root, 'package.json')
            if (exists(packageJsonPath)) {
                try {
                    const { name, version, description } = await read(packageJsonPath)
                    cap.appDescription = cap.appDescription ?? description
                    cap.appVersion = cap.appVersion ?? version
                    if (name) {
                        const segments = name.trim().replace(/@/g, '').split('/').map(encodeURIComponent)
                        cap.appName = cap.appName ?? segments[segments.length - 1]
                        cap.appId = cap.appId ?? segments.join('.')
                        cap.appDescription = cap.appDescription ?? cap.appName
                    }
                } catch (e) {
                    LOG.error(`Failed to read file ${packageJsonPath} - skip application data`)
                    LOG.error(e)
                }
            }
        }

        // 2. use project name and static default values
        cap.appName = cap.appName ?? path.basename(cds.root)
        cap.appDescription = cap.appDescription ?? cap.appName + " application"
        cap.appId = cap.appId ?? cap.appName
        cap.appVersion = cap.appVersion ?? '1.0.0'
    }

    _hasHanaServiceBinding(env) {
        const db = env?.requires?.db
        return db?.kind === 'hana' || db?.kind === 'sql' && (db?.dialect === 'hana' || db?.use === 'hana')
    }

    // REVISIT: Only used for orphaned cds add cf-manifest. Still needed?
    _setResourceDependencies(env, cap) {
        for (const [key, require] of Object.entries(env.requires)) {
            if (key === 'sql' || key === 'sqlite' || key === 'hana') continue // ignore abstract helper definitions like sql
            const resource = this._getReqResource(key, require, cap)
            if (resource) cap.requires.push({ resource }) // using production profile
        }
    }

    _getReqResource(key, reqEntry, cap) {
        const { kind, dialect, use, vcap = {}, multiTenant } = reqEntry
        const { appName, isMultitenant } = cap
        const resource = {
            name: !key.includes(appName) ? `${appName}-${key}` : key,
            service: '',
            vcap,
            get isMultitenant() { return isMultitenant || multiTenant || false },
            get isManagedHana() { return this.vcap.label === 'service-manager' || this.service === 'service-manager' },
            get isPlainHana()   { return this.service === 'hana' && !this.isManagedHana },
            get isHana()        { return this.isPlainHana || this.isManagedHana },
            get isXsuaa()       { return this.service === 'xsuaa' },
        }

        switch (kind) {
            case 'sql':
            case 'hana':
                if (kind === 'sql' && dialect !== 'hana' && use !== 'hana') {
                    break
                }
                // use different service name to avoid conflicts when switching from single tenant to multitenant
                // otherwise we would enforce that users have to delete the db container first
                if (resource.isMultitenant) {
                    resource.service = 'service-manager'
                    resource.vcap.plan = 'container'
                } else {
                    resource.service = 'hana'
                    resource.vcap.plan = 'hdi-shared'
                }
                break

            case 'xsuaa':
                resource.service = kind
                resource.vcap.plan = 'application'
                break
            default: {
                vcap.plan ? resource.service = kind : DEBUG && DEBUG(`Skip resource ${key}`)
            }
        }
        return resource.service ? resource : null
    }
}
