module.exports = Object.assign (env, {
  options: ['--for', '--mocked'], flags: ['--process-env', '--resolve-bindings'], shortcuts: ['-4', undefined, '-P', '-b'],
  help: `
# SYNOPSIS

    *cds env* [get] [<key>]
    *cds env* list [<key>]
    *cds env* ls [<key>]
    *cds env* src

# EXPLANATION

    Displays the effective configuration for the given key, or all of the
    current environment. By default and when using *get* the output is in
    _object_ format. When using *list* or *ls* it's in _.properties_ format.

# OPTIONS

    *-4* | *--for* | *--profile* <profile,...>

       Load configuration for the specified profile(s).

    *-P* | *--process-env*

       Show properties from Node.js _process.env_.

    *-b* | *--resolve-bindings*

       Resolve _cds bind_ bindings.
`})

const path = require('path')

const {inspect} = require('util')
const term = require('../lib/util/term')
const info = (s) => process.stdout.isTTY ? term.info (s) : s

async function env ([cmd, key, value], options={}) {

  if (options.for) process.env.CDS_ENV = options.for

  const cds = require('../lib/cds')
  const fn = (
    options["process-env"] ? processEnvCommands[cmd] :
    commands[cmd] || ((key = cmd), commands.get)
  )

  let env = cds.env
  if (options["resolve-bindings"]) {
    const BindingManager = require('../lib/bind/bindingManager')
    const bindingManager = new BindingManager({ env, silent: true })
    const bindingEnv = await bindingManager.bindingEnv()
    Object.assign(process.env, bindingEnv)
    env = cds.env.for(options.for || 'cds') // reload env
  }
  env['_home_cds-dk'] = path.resolve(__dirname, '..')  // to help tools find the DK

  if (!options.for && options.mocked)  await cds.service.bindings
  return fn (env, key, value)
}


const commands = {

  get ls()   { return this.list },

  // eslint-disable-next-line no-unused-vars
  list (conf, _key, val) { // NOSONAR
    (function _list (o = _key ? conf.get(_key.replace(/^cds\./,'')) : conf, key = _key || '') {  // NOSONAR, ...tzefix!!
      if (o && typeof o === 'object' && !Array.isArray(o)) for (let p of Object.keys(o).sort()) {
        const d = Reflect.getOwnPropertyDescriptor (o,p)
        if (d.value === undefined && d.get === undefined)  continue
        if (o[p] !== undefined)  _list (o[p], (key ? key+'.' : '')+p)
      } else  console.log (info(key), '=',o)
    })()
  },

  // eslint-disable-next-line no-unused-vars
  src (conf, key, val) {
    console.log()
    for (let each of [...conf._sources].reverse())  console.log (' ', each)
    console.log()
  },

  get (conf, key, val) {
    if (!process.stdout.isTTY)  return commands.json (conf, key, val)
    // tty: display formatted object
    const obj = key ? conf.get(key.replace(/^cds\./,'')) : conf
    console.log (inspect (obj, {depth:22,colors:true}).replace(/\s+use:.*\[Getter\][^,]+,?/g,''))
  },

  // eslint-disable-next-line no-unused-vars
  json (conf, key, val) {
    const obj = (key ? conf.get(key.replace(/^cds\./,'')) : conf)
    const str = JSON.stringify(obj, null, 2)
    return console.log (str ? str.replace(/\s+use:.*\[Getter\][^,]+,?/g,'') : str)
  },

  set () {
    console.error ('cds env set is not yet implemented, sorry.')
  }
}

const processEnvCommands = {
  get [undefined]() { return processEnvCommands.list },
  get ''() { return processEnvCommands.list },
  get ls()   { return process.list },

  list (_, key) {
    if (key) {
      processEnvCommands.get(undefined, key)
    } else {
      for (const name in process.env) {
        console.log(`${name}=${process.env[name]}`)
      }
    }
  },

  get (_, key) {
    console.log (process.env[key] || "")
  }
}

/* eslint no-console:0 */
